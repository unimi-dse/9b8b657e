# a value to be assigned to x.
#adjustOHLC
#con questa funzione, con base ai parametri che ha messo (use.Adjusted=TRUE),
#va ad usare il prezzo adjustes close
start_t<-Sys.time()
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
chart.Posn(Portfolio=PORTFOLIOID,Symbol= assetname, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#quest'ultima è di PLOTTER
}
stratMACROSS<- strategy('PORTFOLIOMY4') #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
buildbacktestinfrastructure("PORTFOLIOMY4","2019-01-01", stratMACROSS, data, "KCSUSDT" )
buildbacktestinfrastructure("PORTFOLIOMY4","2019-01-01", stratMACROSS, data, "KCS-USDT" )
buildbacktestinfrastructure("PORTFOLIOMY6","2019-01-01", stratMACROSS, data, "KCS-USDT" )
?initPortf
getnumericdata <- function(date){
daytimestring = paste0(date, "08:00:00", "GMT")
posixctdate = as.POSIXct(daytimestring)
numberdate = as.integer(as.numeric(posixctdate))
return(numberdate)
}
require(httr)
#THERE IS A CONSTRAINT OF 1500 CANDLES IN THE REQUEST TO THE RESTFUL API...
#A WEBSOKET CONNECTION WILL BE NEEDED...
#provide criptocurrencies pairs data starting on provided datetime at 08:00 AM GMT
#date format yyyymmdd
#Type of candlestick (relevationfrequency) : 1min, 3min, 5min, 15min, 30min, 1hour, 2hour, 4hour, 6hour, 8hour, 12hour, 1day, 1week
GetKucoinData <- function(criptopair, relevationfrequency, startdate, enddate ){
# set GMT timezone. See documentation
#Sys.setenv(TZ='GMT-1') no more needed
# API base url. See documentation
baseurl <- 'https://api.kucoin.com'
# API endpoint. See documentation
endpoint <- '/api/v1/market/candles'
da = getnumericdata(startdate)
finoa =  getnumericdata(enddate)
# API parameters. See documentation
param <- c(symbol = criptopair, type = relevationfrequency, startAt = da, endAt = finoa)
# build full url. See documentation
url <- paste0(baseurl, endpoint, '?', paste(names(param), param, sep = '=', collapse = '&'))
# retrieve url
x <- GET(url)
# extract data
x <- content(x)
data <- x$data
data <- sapply(1:length(data), function(i) {
# extract single candle
candle <- as.numeric(data[[i]])
# formatting. See documentation
return( c(time = candle[1], open = candle[2], close = candle[3], high = candle[4], low = candle[5]) )
})
# convert to xts
datetime <- as.POSIXct(data[1,], origin = '1970-01-01')
data <- xts(t(data[-1,]), order.by = datetime)
return(data)
}
require(quantstrat)
buildbacktestinfrastructure <-function(portfolioidentifier, startingdate, strategyobject, criptodata, assetname){
#stock.str= assetname # what are we trying it on
currency('USD')
#stock(stock.str,currency="USD",multiplier=1)  #todo: add the specific currency
PORTFOLIOID = portfolioidentifier
startDate= startingdate
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(PORTFOLIOID, assetname) #st,symbols=stock.str)   #QUESTA FUNZIONE FA PARTE DI BLOTTER
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)  #QUESTA FUNZIONE FA PARTE DI BLOTTER
initOrders(portfolio=portfolio.st) #questo fa parte di quantstrat
closingprice = criptodata[,2]
assetname = closingprice
start_t<-Sys.time()
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
chart.Posn(Portfolio=PORTFOLIOID,Symbol= assetname, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#quest'ultima è di PLOTTER
}
View(data)
data = GetKucoinData('ETH-BTC','1min','2019-01-01','2019-12-31')
stratMACROSS<- strategy('11021') #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
buildbacktestinfrastructure("11021","2019-01-01", stratMACROSS, data, "ETHBTC" )
require(quantstrat)
buildbacktestinfrastructure <-function(portfolioidentifier, startingdate, strategyobject, criptodata, assetname){
stock.str= assetname # what are we trying it on
currency('USD')
stock(stock.str,currency="USD",multiplier=1)  #todo: add the specific currency
PORTFOLIOID = portfolioidentifier
startDate= startingdate
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(PORTFOLIOID, assetname) #st,symbols=stock.str)   #QUESTA FUNZIONE FA PARTE DI BLOTTER
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)  #QUESTA FUNZIONE FA PARTE DI BLOTTER
initOrders(portfolio=portfolio.st) #questo fa parte di quantstrat
closingprice = criptodata[,2]
assetname = closingprice
start_t<-Sys.time()
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
chart.Posn(Portfolio=PORTFOLIOID,Symbol= assetname, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#quest'ultima è di PLOTTER
}
buildbacktestinfrastructure("11021","2019-01-01", stratMACROSS, data, "ETHBTC" )
stratMACROSS<- strategy('11022') #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
buildbacktestinfrastructure("11022","2019-01-01", stratMACROSS, data, "ETHBTC" )
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]
stock.str='ADABTC' # what are we trying it on
currency('USD')
stock(stock.str,currency="USD",multiplier=1)  #todo: add the specific currency
PORTFOLIOID = "03"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)   #QUESTA FUNZIONE FA PARTE DI BLOTTER
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)  #QUESTA FUNZIONE FA PARTE DI BLOTTER
initOrders(portfolio=portfolio.st) #questo fa parte di quantstrat
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=10),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=20),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
#now we get the data
ADABTC = closingprice
#GETSYMBOLS (di quantmod) posiziona nell'enviroment attuale il dataframe con i dati
#funanziari del titolo richiesto; il nome del df sarà il tag indicato come primo parametro.
start_t<-Sys.time()
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#quest'ultima è di PLOTTER
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#quest'ultima è di PLOTTER
View(closingprice)
View(closingprice)
backtestfunction <- function(closingprice, stock.str, portfolioidentifier){
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = portfolioidentifier
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=10),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=20),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
#PLOT THE BACKTEST RESULTS:
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
}
W = GetKucoinData("BTC-USDT", "1min", "2019-12-31", "2020-01-31")
PRICETOTRADE = W[,2]
stockSTR='BTCUSDT'
backtestfunction(PRICETOTRADE,stockSTR,"10")
stock.str='BTCUSDT'
backtestfunction(PRICETOTRADE,stock.str,"11")
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "03"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=10),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=20),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
#PLOT THE BACKTEST RESULTS
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "03"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "11"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "11"
startDate="2018-01-01"
initEq=1000000
require(httr)
#THERE IS A CONSTRAINT OF 1500 CANDLES IN THE REQUEST TO THE RESTFUL API...
#A WEBSOKET CONNECTION WILL BE NEEDED...
#provide criptocurrencies pairs data starting on provided datetime at 08:00 AM GMT
#date format yyyymmdd
#Type of candlestick (relevationfrequency) : 1min, 3min, 5min, 15min, 30min, 1hour, 2hour, 4hour, 6hour, 8hour, 12hour, 1day, 1week
GetKucoinData <- function(criptopair, relevationfrequency, startdate, enddate ){
baseurl <- 'https://api.kucoin.com'
endpoint <- '/api/v1/market/candles'
da = getnumericdata(startdate)
finoa =  getnumericdata(enddate)
param <- c(symbol = criptopair, type = relevationfrequency, startAt = da, endAt = finoa)
url <- paste0(baseurl, endpoint, '?', paste(names(param), param, sep = '=', collapse = '&'))
x <- GET(url)
x <- content(x)
data <- x$data
data <- sapply(1:length(data), function(i) {
candle <- as.numeric(data[[i]])
return( c(time = candle[1], open = candle[2], close = candle[3], high = candle[4], low = candle[5]) )
})
datetime <- as.POSIXct(data[1,], origin = '1970-01-01')
data <- xts(t(data[-1,]), order.by = datetime)
return(data)
}
getnumericdata <- function(date){
daytimestring = paste0(date, "08:00:00", "GMT")
posixctdate = as.POSIXct(daytimestring)
numberdate = as.integer(as.numeric(posixctdate))
return(numberdate)
}
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "11"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "15"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=10),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=20),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
#PLOT THE BACKTEST RESULTS
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "16"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
require(httr)
#THERE IS A CONSTRAINT OF 1500 CANDLES IN THE REQUEST TO THE RESTFUL API...
#A WEBSOKET CONNECTION WILL BE NEEDED...
#provide criptocurrencies pairs data starting on provided datetime at 08:00 AM GMT
#date format yyyymmdd
#Type of candlestick (relevationfrequency) : 1min, 3min, 5min, 15min, 30min, 1hour, 2hour, 4hour, 6hour, 8hour, 12hour, 1day, 1week
GetKucoinData <- function(criptopair, relevationfrequency, startdate, enddate ){
baseurl <- 'https://api.kucoin.com'
endpoint <- '/api/v1/market/candles'
da = getnumericdata(startdate)
finoa =  getnumericdata(enddate)
param <- c(symbol = criptopair, type = relevationfrequency, startAt = da, endAt = finoa)
url <- paste0(baseurl, endpoint, '?', paste(names(param), param, sep = '=', collapse = '&'))
x <- GET(url)
x <- content(x)
data <- x$data
data <- sapply(1:length(data), function(i) {
candle <- as.numeric(data[[i]])
return( c(time = candle[1], open = candle[2], close = candle[3], high = candle[4], low = candle[5]) )
})
datetime <- as.POSIXct(data[1,], origin = '1970-01-01')
data <- xts(t(data[-1,]), order.by = datetime)
return(data)
}
getnumericdata <- function(date){
daytimestring = paste0(date, "08:00:00", "GMT")
posixctdate = as.POSIXct(daytimestring)
numberdate = as.integer(as.numeric(posixctdate))
return(numberdate)
}
require(quantstrat)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "16"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
#PLOT THE BACKTEST RESULTS
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
library(sirdan)
library(sirdan)
require(sirdan)
W = GetKucoinData("ADA-BTC", "1min", "2019-12-31", "2020-01-31")
closingprice = W[,2]   #we will trade on the candle's closing price
stock.str='ADABTC'
currency('USD')  #to do, modify the possibility to add other currencies (eg criptocurrencies)
stock(stock.str,currency="USD",multiplier=1)
#SET THE BACKTEST PROPERTIES:
PORTFOLIOID = "16"
startDate="2018-01-01"
initEq=1000000
portfolio.st=PORTFOLIOID
account.st=PORTFOLIOID
initPortf(portfolio.st,symbols=stock.str)
initAcct(account.st,portfolios=portfolio.st, initEq=initEq)
initOrders(portfolio=portfolio.st)
#STRATEGY DEFINITION:
stratMACROSS<- strategy(portfolio.st) #l'oggetto (funzione) strategy fa parte di quantstrat
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=50),label= "ma50" )
stratMACROSS <- add.indicator(strategy = stratMACROSS, name = "SMA", arguments = list(x=quote(closingprice), n=200),label= "ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(columns=c("ma50","ma200"), relationship="gte"),label="ma50.gt.ma200")
stratMACROSS <- add.signal(strategy = stratMACROSS,name="sigCrossover",arguments = list(column=c("ma50","ma200"),relationship="lt"),label="ma50.lt.ma200")
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.gt.ma200",sigval=TRUE, orderqty=100, ordertype='market', orderside='long'),type='enter')
stratMACROSS <- add.rule(strategy = stratMACROSS,name='ruleSignal', arguments = list(sigcol="ma50.lt.ma200",sigval=TRUE, orderqty='all', ordertype='market', orderside='long'),type='exit')
ADABTC = closingprice
start_t<-Sys.time()
#RUNNING THE BACKTEST:
out<-applyStrategy(strategy=stratMACROSS , portfolios=portfolio.st)
end_t<-Sys.time()
print(end_t-start_t)
start_t<-Sys.time()
updatePortf(Portfolio=PORTFOLIOID,Dates=paste('::',as.Date(Sys.time()),sep=''))
end_t<-Sys.time()
print("trade blotter portfolio update:")
print(end_t-start_t)
#PLOT THE BACKTEST RESULTS
chart.Posn(Portfolio=PORTFOLIOID,Symbol=stock.str, TA=c("add_SMA(n=50,col='red')","add_SMA(n=200,col='blue')"))
